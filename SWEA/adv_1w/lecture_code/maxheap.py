'''
7
20 15 19 4 13 11 17

7
20 15 19 4 13 11 23

---------------------
나는 N = 7, arr = [2, 7, 5, 1, 4, 3, 6]
으로 코드 읽어봤는데
last = 0에서 시작하고
h는 인덱스 번호를 1부터 시작하려고 길이가 N + 1이고,
enq()함수만 봤을 때 물론 N + 1개 짜리 0 리스트긴 하지만
데이터를 넣을 마지막 노드를 last로 리스트 인덱스를 지정해준거야
그래서 처음 숫자를 넣을 때는 1번 인덱스에, 그 다음은 2번 인덱스, ... , 이렇게 할 때
last를 +1 해가면서 데이터 삽입 인덱스로 쓰는거지.
그러면서 last 인덱스에 데이터를 삽입하고, 그 데이터와 그 last를 2로 나눈 몫(부모 노드 번호)이 인덱스인 리스트의 값(부모 노드 값)과 비교하는거야
while문은 last 인덱스 데이터가 더 크면 그 데이터의 부모와 바꾸는 과정이고, 바꾼 뒤에 c를 다시 부모 인덱스로 지정하고,
그 c의 부모 인덱스를 계속 비교해가면서 가장 큰 값이 root node로 가게 만드는거지
일단 enq() 함수는 이렇게 진행돼서 내 예시를 결과로 출력하면
h = [0, 7, 4, 6, 1, 2, 3, 5]
트리 모양으로 나타내면
        7
    4         6
 1     2    3    5
이렇게 나옴

'''


# 최대힙
def enq(n):
    global last
    last += 1   # 마지막 노드 추가(완전이진트리 유지)
    h[last] = n # 마지막 노드에 데이터 삽입
    c = last    # 부모>자식 비교를 위해
    p = c//2    # 부모번호 계산
    while p >= 1 and h[p] < h[c]:   # 부모가 있는데, 더 작으면
        h[p], h[c] = h[c], h[p]  # 교환
        c = p
        p = c//2


def deq():
    global last
    tmp = h[1]   # 루트의 키값 보관
    h[1] = h[last]
    last -= 1
    p = 1           # 새로 옮긴 루트
    c = p*2
    while c <= last:  # 자식이 있으면
        if c+1 <= last and h[c] < h[c+1]: # 오른쪽자식이 있고 더 크면
            c += 1
        if h[p] < h[c]:
            h[p], h[c] = h[c], h[p]
            p = c
            c = p*2
        else:
            break
    return tmp


N = int(input())          # 필요한 노드 수
arr = list(map(int, input().split()))

h = [0]*(N+1)   # 최대힙
last = 0        # 힙의 마지막 노드 번호

for num in arr:
    enq(num)

print(h)

while last > 0:
    print(deq(), end=' ')
